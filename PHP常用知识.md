#### 1.GET和POST的区别

| GET                                   | POST                                |
| ------------------------------------- | ----------------------------------- |
| 从服务器拉取数据                              | 传输数据到服务器                            |
| 参数存在于URL中，且数据量大小 小于**2k**（取决于**浏览器**） | 参数存在于body中，数据量大小理论上没有限制（取决于**服务器**） |
| 安全性较差，处理效率要高                          | 安全性相对较强，处理效率相对较低                    |

#### 2.Cookie 和 Session 的区别和关系

| cookie | session                   |
| ------ | ------------------------- |
| 存在于客户端 | 存在于服务端                    |
|        | session跟踪会话有：cookie，URL重写 |

#### 3.isset和empty的区别

​	isset：是用来判断某个变量是否存在

​			若变量不存在或者为null，则返回false;

​	empty：判断变量是否为空

​			若为 null,0,"",false,array()，以及没有任何属性的对象，则返回true;

#### 4.echo、print_r、print、var_dump 之间的区别

​	echo 是**PHP语法**，打印字符串信息

​	print 打印**字符串**

​	print_r 打印字符串、数组、对象等信息，也可以**存储到变量中**

​	var_dump 打印字符串、数组、对象等信息，并返回**变量的类型**

#### 5.PHP7和PHP5的区别

​	1.性能提升2倍 ：减少内存分配次数，多使用栈内存，缓存数组hash值，使用大连续内存代替小块碎片内存等。

​	2.新增标量类型和返回类型声明 。可以强制当前文件下的程序遵循严格的函数传参类型和返回类型。

​	3.更多的Error变为可捕获的Exception。

​	4.增加了匿名类，现在支持通过new class来实例化一个匿名类，这可以用来替代一些“用后即焚”的完整类定义。

#### 6.为什么PHP7 比 PHP5 性能提升了

​	1.变量存储字节减小，减少内存占用，提升变量操作速度。

​	2.改善数组结构，数组元素和hash映射表被分配在同一块内存里，降低了内存占用，提升了CPU缓存命中率。

​	3.改进了函数的调用机制，通过优化参数传递的环节，减少了一些指令，提高执行效率。

#### 7.PHP垃圾回收机制（GC）

​	PHP5.3之前的版本都是采用引用计数的方式管理内存，PHP所有的变量存在一个叫zval的变量容器中，当变量被引用的时候，引用计数会+1，变量引用计数变为0时，PHP将在内存中销毁这个变量。

​	这样在引用计数中的循环引用，引用计数不会消减为0，就会导致内存泄露。

​	php5.3之后的版本：

​	1.PHP会分配一个固定大小的“根缓存区”，这个缓冲区存放一定数量的zval，默认为10000，PHP会将zval投入根缓存区。

​	2.对每个跟缓冲区的根zval深度优先遍历 ，并将zval的refcount_gc减1，并标记为“已减”。

​	3.再次对每个缓冲区的根zval深度优先遍历，如果某个zval的refcount不为0，则加1，否则保持为0。

​	4.清空根缓冲区中的所有根（把这些zval从缓冲区中清除而不是销毁它们），然后销毁所有refcount为0的zval，并回收其内存。



​	PHP5.3的垃圾回收特性：

​		1.并不是每次refcount减少时都进入回收周期，只有**根缓冲区满额**后才开始垃圾回收。

​		2.可以解决循环引用问题。

​		3.可以将内存泄露保持在一个阈值以下。

​	

#### 8.如何解决内存溢出问题

​	1.增大PHP脚本的内存分配

​	2.变量引用之后及时销毁

​	3.将数据分批处理

#### 9.redis、memchched的区别

|      | Redis                                | Memcached             |
| ---- | ------------------------------------ | --------------------- |
|      | 支持key-value、hash、List、set和Sorted set | 只支持key-value格式        |
|      | 数据可持久化存储                             | 数据存在于内存中              |
|      | 支持事务功能，可保证一系列命令的原子性                  |                       |
|      | 当空间占满后，会将不常用的数据移到磁盘上，挪出空间            | 当内存空间占满后，会删除掉不常用的内存数据 |
|      | 只支持单核                                | 可使用多核                 |

#### 10.redis如何实现持久化

​	1.RDB持久化，每隔一段时间，将Redis数据**完整备份**到磁盘上（二进制）	rdb.h rdb.c。

​	2.AOF持久化，每隔一段时间，将这段时间的redis写入命令记录到文件中 aof.c。



#### 11.CSRF是什么？如何防范？

​	CSRF:cross-site request forgery，跨站请求伪造。攻击者**盗用用户身份**，从而欺骗服务器，来完成攻击请求。

​	防范：

​		1.给每一个请求添加令牌token并验证。 

​		2.使用验证码。

#### 12.XSS是什么？如何防范？

​	XSS：Cross Site Scripting，跨站脚本攻击。攻击者往web页面里恶意插入script代码。当用户浏览该页之时，嵌入其中web里面的script代码会被执行，从而达到恶意攻击用户的目的。

​	如何防范？

​		对用户数据进行过滤

13.什么是SQL注入？如何防范？

​	SQL注入就是攻击者通过一些方式欺骗服务器，结果执行了一些不该被执行的SQL。

​	SQL注入的**常见场景**

​		1.数据库里被注入了大量的垃圾数据，导致服务器运行缓、崩溃。

​		2.利用sql注入暴露了应用程序的隐私数据。

​	如何防范？

​		1.对用户数据进行过滤

​		2.SQL不要进行动态拼装

​		3.增加输入验证，比如验证码

​		4.对隐私数据加密，进制明文存储



#### 13.MyISAM和InnoDB的区别

|      | MyISAM        | InnoDB |
| ---- | ------------- | ------ |
|      | 不支持事务         | 支持事务   |
|      | count(*)不用查全表 |        |
|      |               |        |
|      |               |        |
|      |               |        |



